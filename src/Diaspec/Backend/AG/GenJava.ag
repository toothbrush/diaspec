{
import qualified Language.Java.Syntax as J
import Data.String.Utils (split)
}

----------------------------------
-- Java generation
----------------------------------

attr Declaration
  syn genJ :: {J.CompilationUnit}  -- pretty printing (multiline mode)

attr Type
  syn genJ :: {J.RefType}

sem Declaration
  | Source      lhs.genJ = clsSource @name @ty.genJ
  | Action      lhs.genJ = undefined
  | Context     lhs.genJ = undefined
  | Controller  lhs.genJ = undefined

-- | determines the return type of a context.
-- sem Publish
--   | AlwaysPublish    lhs.genJ = text $ show @self
--   | MaybePublish     lhs.genJ = text $ show @self
-- 
sem Type
  | Bool    lhs.genJ = jtype @self
  | Int     lhs.genJ = jtype @self
  | Picture lhs.genJ = jtype @self
  | String  lhs.genJ = jtype @self

-- sem ControllerInteraction
--   | WhenContext     lhs.genJ = text "when_provided" >#< text @name
--                                 >-< text "do" >#< text @act
-- | influences name, 
-- sem ContextInteraction
--   | WhenRequired    lhs.genJ = text "when_required" >-< @get.genJ
--   | WhenProvided    lhs.genJ = text "when_provided" >#< text @name
--                                 >-< @get.genJ >-< @pub.genJ
-- 
-- | add proxy or not
-- sem Get
--   | Nothing   lhs.genJ = empty
--   | Just      lhs.genJ = text "get" >#< text @just

{

clsSource :: String  -- ^ class name
    -- -> [TypeParam]   -- ^ for generic classes: type parameters
    -- -> Maybe RefType -- ^ extends
    -- -> [RefType]     -- ^ implements, sources always implement "Source"
    -> J.RefType -- output type of the source.
    --  -> ClassBody
    -> J.CompilationUnit
clsSource clname ty =
  J.CompilationUnit pack
  [] -- no imports
  [J.ClassTypeDecl $ J.ClassDecl publicAbstract
   (J.Ident$ "Abstract"++clname)
   [] -- not a generic class, hence no type parameters
   (Just -- extends something. Maybe TypeRef
    (J.ClassRefType
     (J.ClassType
      [(J.Ident
        "Publisher", -- all sources extend publisher, with their type.
        [J.ActualType ty]
        )])))
   [J.ClassRefType
    (J.ClassType
     [(J.Ident
       "Source",[])])]
   (J.ClassBody [J.MemberDecl $ sourceMethod clname ty])]

publicAbstract = [J.Public, J.Abstract] -- we only generate public abstract classes. except for proxies, they're protected final.

pack = packagify "fr.diaspec.scenarioname.generated" -- TODO scenarioname, inherit.
  where packagify s = Just (J.PackageDecl (J.Name (map J.Ident (split "." s)))) 

jtype :: Type -> J.RefType
jtype t = case t of
     Bool    -> wrap "Boolean"
     Int     -> wrap "Integer"
     String  -> wrap "String"
     Picture -> wrap "Bitmap" 
  where
    wrap :: String -> J.RefType
    wrap s = J.ClassRefType (J.ClassType
                             [(J.Ident s,[])])

sourceMethod :: String -- ^ name of source
             -> J.RefType -- ^ expected return type.
             -> J.MemberDecl
sourceMethod nm ty = (J.MethodDecl publicAbstract
                           [] (Just$ J.RefType ty)
                           (J.Ident$ "get"++nm++"Value") [] [] (J.MethodBody Nothing))
  
}
