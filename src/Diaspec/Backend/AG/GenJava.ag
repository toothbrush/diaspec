imports
{
import Language.Java.Syntax
import Data.Maybe (fromJust)

import Diaspec.JTypeUtils
}

{
type TyEnv = [(String, DType)]
}

----------------------------------
-- Java generation
----------------------------------

-- TODO split the two AGs: for pprinting and for compilation.
attr Specification Declarations
  syn genJ   :: {[CompilationUnit]}

attr Declaration
  syn genJ   :: {CompilationUnit}

attr Declarations Declaration
  inh pkg      :: {Maybe PackageDecl}  -- the package name, derived from specs filename
  inh tyEnv    :: {TyEnv} -- environment to keep track of output types of components.

attr Declarations
  syn allTypes :: {TyEnv}

attr Declaration
  syn myType   :: {TyEnv}

attr DType
  syn javaType :: {RefType}


attr ContextInteraction
  inh ty      :: {DType}

attr ContextInteraction ControllerInteraction
  syn classImplements :: {[RefType]}
  inh tyEnv    :: {TyEnv} -- environment to keep track of output types of components.
  inh thisCName :: {String}
  syn methods :: {[Decl]}

attr Publish
  inh ty      :: {DType} -- turn it into a Maybe, maybe.
  syn ret     :: {Type}
  syn notify  :: {BlockStmt}

attr Get
  inh tyEnv   :: {TyEnv}
  syn args    :: {[Exp]}
  syn fparam  :: {[(RefType, String)]}
  syn initProxy :: {[BlockStmt]}
  syn destrProxy :: {[BlockStmt]}
  syn proxyClass :: {[Decl]}
                 
sem Specification
  | S        lhs.genJ  = @ds.genJ 
             ds.tyEnv  = @ds.allTypes
             ds.pkg    = pack @name

sem Declarations
  | Cons     lhs.genJ = @hd.genJ : @tl.genJ -- TODO figure out why list is reversing
             lhs.allTypes = @hd.myType ++ @tl.allTypes
  | Nil      lhs.genJ     = []
             lhs.allTypes = []

sem DType
  | DBool    lhs.javaType = jtype @self
  | DInt     lhs.javaType = jtype @self
  | DPicture lhs.javaType = jtype @self
  | DString  lhs.javaType = jtype @self

sem Declaration
  | Source      lhs.genJ = clsSource @lhs.pkg @name @ty.javaType
                lhs.myType = [(@name, @ty.self)]
  | Action      lhs.genJ = clsAction @lhs.pkg @name @ty.javaType
                lhs.myType = []
  | Context     lhs.genJ = clsContext @lhs.pkg @name @contr.classImplements -- implements, which depend on IC.
                           @ty.self @contr.methods
                contr.ty = @ty.self
                contr.thisCName = @name
                lhs.myType = [(@name, @ty.self)]
  | Controller  lhs.genJ   = clsController @lhs.pkg @name @contr.classImplements @contr.methods
                contr.thisCName = @name
                lhs.myType = []

-- | influences name of member method, 
sem ContextInteraction
  | WhenProvided lhs.classImplements = [ClassRefType (ClassType [(Ident "Context",[])]),
                                        ClassRefType (ClassType [(Ident "Subscriber",
                                                                  [ActualType @loc.inType])])]
                 loc.inType = jtype (fromJust $ lookup @name @lhs.tyEnv) 
                 loc.methName = "on" ++ @name ++ "Provided"
                 lhs.methods= [ methodDecl protectedAbstract (Just @pub.ret) --return
                                @loc.methName
                                (funcparams $ (@loc.inType, "newValue") :  @get.fparam)
                                Nothing
                              , methodDecl publicFinal Nothing
                                "trigger"
                                (funcparams$ (@loc.inType, "value") : [])
                                (stmts $
                                  @get.initProxy ++
                                  [ lVar @pub.ret "v"
                                     (Just (InitExp (MethodInv (MethodCall
                                        (Name [Ident @loc.methName]) (ExpName (Name [Ident "value"]) : @get.args)))))]
                                  ++ @get.destrProxy ++
                                  [@pub.notify])
                              ]
                              ++ @get.proxyClass
                              ++ runnerInit True
  | WhenRequired lhs.classImplements = [ClassRefType (ClassType [(Ident "Context",[])])]
                 loc.methName = "when" ++ @lhs.thisCName ++ "Required"
                 loc.myType  = jtype . fromJust $ lookup @lhs.thisCName @lhs.tyEnv
                 lhs.methods= [ methodDecl protectedAbstract
                                (Just$ RefType @loc.myType) --return TODO simple inh instead of lookup?
                                @loc.methName (funcparams @get.fparam) -- TODO proxy??
                                Nothing
                              , methodDecl [Protected, Final] Nothing "requireValue"
                                [] -- no args
                                (stmts$
                                 @get.initProxy ++
                                 [lVar (RefType @loc.myType) "v"
                                  (Just (InitExp (MethodInv (MethodCall
                                                             (Name [Ident @loc.methName])
                                                             @get.args))))
                                 ] ++
                                 @get.destrProxy ++
                                 [ BlockStmt (Return (Just (ExpName (Name [Ident "v"]))))
                                 ])
                              ] ++ @get.proxyClass ++ runnerInit True

sem ControllerInteraction
    | WhenContext     lhs.classImplements = [ClassRefType (ClassType [(Ident "Controller",[])]),
                                             ClassRefType (ClassType [(Ident "Subscriber",
                                                                       [ActualType @loc.inType])])]
                      loc.inType = jtype (fromJust $ lookup @name @lhs.tyEnv) 
                      loc.methName = "on" ++ @name ++ "Provided"
                      loc.vName  = "proxy"
                      loc.proxyName = @act ++ "Proxy"
                      lhs.methods= [ methodDecl protectedAbstract Nothing --return
                                     @loc.methName
                                     (funcparams $ (@loc.inType, "newValue") :  @loc.proxyparam)
                                     Nothing
                                   , methodDecl publicFinal Nothing
                                     "trigger"
                                     (funcparams$ (@loc.inType, "value") : [])
                                     (stmts $
                                       @loc.initProxy ++
                                       [BlockStmt (ExpStmt
                                                   (MethodInv (MethodCall (Name [Ident @loc.methName])
                                                               [ExpName (Name [Ident "value"])
                                                               ,ExpName (Name [Ident @loc.vName])])))] -- call on..Provided
                                       ++ @loc.destrProxy)
                                   ]
                                   ++ @loc.proxyClass
                                   ++ runnerInit True
                      loc.proxyparam = [(ClassRefType (ClassType [(Ident @loc.proxyName,[])]), @loc.vName)]
                      loc.initProxy  = proxyOn  @loc.proxyName @loc.vName
                      loc.destrProxy = proxyOff @loc.proxyName @loc.vName
                      loc.proxyClass = [proxyClDo @act @loc.proxyName (funcparams$(@loc.inType, "value"):[])]


-- | determines the return type of a context.
sem Publish
  | AlwaysPublish    lhs.ret    = RefType$ jtype @lhs.ty
                     lhs.notify = BlockStmt
                                   (ExpStmt
                                    (MethodInv (MethodCall (Name [Ident "notify"])
                                                [ExpName (Name [Ident "v"])])))
  | MaybePublish     lhs.ret    = RefType (ClassRefType (ClassType [(Ident "Maybe",[ActualType$ jtype @lhs.ty])]))
                     lhs.notify = BlockStmt
                                  (IfThen (InstanceOf (ExpName (Name [Ident "v"])) (ClassRefType (ClassType [(Ident "Just",[])])))
                                   (ExpStmt
                                    (MethodInv
                                     (MethodCall (Name [Ident "notify"])
                                      [FieldAccess
                                       (PrimaryFieldAccess
                                        (Cast
                                         (RefType
                                          (ClassRefType
                                           (ClassType
                                            [(Ident "Just",[ActualType$ jtype @lhs.ty])])))
                                         (ExpName (Name [Ident "v"]))) (Ident "just_value"))]))))

-- | add proxy or not
sem Get
  | Nothing   lhs.args       = [] -- no proxy to method invocation.
              lhs.fparam     = [] -- no extra argument to abstract method
              lhs.initProxy  = []
              lhs.proxyClass = []
              lhs.destrProxy = []
  | Just      lhs.args       = [ExpName (Name [Ident "proxy"])] -- passed to dev's implementationy
              loc.proxyType  = Just (RefType (jtype.fromJust $ lookup @just @lhs.tyEnv))
              loc.vName      = "local" ++ @just ++ "Proxy"
              loc.proxyName  = @just ++ "Proxy"
              lhs.initProxy  = proxyOn  @loc.proxyName @loc.vName
              lhs.destrProxy = proxyOff @loc.proxyName @loc.vName
              lhs.proxyClass = [proxyClGet @just @loc.proxyName @loc.proxyType]
              lhs.fparam     = [(ClassRefType (ClassType [(Ident @loc.proxyName,[])]), "proxy")]

{
clsContext :: Maybe (PackageDecl)
           -> String  -- ^ class name
           -> [RefType] -- ^ implemented interfaces. depends on interaction contract
           -> DType -- ^ output type of the context.
           -> [Decl] -- ^ the declarations (functions, variables) to be put in the body
           -> CompilationUnit -- ^ gives back full class.
clsContext pkg clname i ty methods =
  clsResource pkg clname
    -- extends Publisher of Ty:
    (Just (ClassRefType (ClassType [(Ident "Publisher",[ActualType$ jtype ty])])))
    -- implements:
    i -- implements Context and perhaps subscriber
    methods -- these depend on the interaction contract etc

clsController :: Maybe (PackageDecl)
              -> String  -- ^ class name
              -> [RefType] -- ^ implemented interfaces. depends on interaction contract
              -> [Decl] -- ^ the functions, variables to be put in the body
              -> CompilationUnit -- ^ gives back full class.
clsController pkg clname i methods =
  clsResource pkg clname
    -- extends nothing
    Nothing
    i -- implements Controller and perhaps subscriber
    methods -- these depend on the interaction contract etc

clsResource :: Maybe (PackageDecl)
            -> String  -- ^ class name
            -> Maybe RefType -- ^ does the class extend anything?
            -> [RefType] -- ^ what does it implement?
            -> [Decl] -- ^ body of the class
            -> CompilationUnit -- ^ give back a complete class
clsResource pkg clname extends implements body =
  CompilationUnit pkg [] -- no imports
  [ClassTypeDecl $ ClassDecl publicAbstract
   (Ident$ "Abstract"++clname)
   [] -- not a generic class, hence no type parameters
   extends implements
   (ClassBody body)]

clsAction :: Maybe (PackageDecl)
          -> String  -- ^ class name
          -> RefType -- ^ input type of the action.
          -> CompilationUnit -- ^ gives back full class.
clsAction pkg clname ty =
  clsResource pkg clname
    Nothing -- does not extend anything
    [ClassRefType (ClassType [(Ident "Action",[ActualType ty])])] -- implements Action
    (actionMethod clname ty)

clsSource :: Maybe (PackageDecl)  -- ^ package name
          -> String  -- ^ class name
          -> RefType -- ^ output type of the source.
          -> CompilationUnit -- ^ gives back a full class.
clsSource pkg clname ty =
  clsResource pkg clname
   (Just -- all sources extend publisher, with their type as Generics param.
    (ClassRefType (ClassType [(Ident "Publisher", [ActualType ty])])))
   [ClassRefType  (ClassType [(Ident "Source",    [ActualType ty])])] -- implements Source interface.
   (sourceMethod clname ty)

publicFinal       = [Public,    Final   ]
publicAbstract    = [Public,    Abstract]
protectedAbstract = [Protected, Abstract]

  
sourceMethod :: String -- ^ name of source
             -> RefType -- ^ expected return type.
             -> [Decl]
sourceMethod nm ty =
  [ methodDecl protectedAbstract (Just$ RefType ty)
    ("get"++nm++"Value") [] Nothing
  , methodDecl [Public] (Just$RefType ty)
    "requireValue" [] (Just (Block [BlockStmt (Return (Just (MethodInv (MethodCall (Name [Ident ("get"++nm++"Value")]) []))))]))
  ]
  
actionMethod :: String -- ^ name of source
             -> RefType -- ^ expected return type.
             -> [Decl]
actionMethod nm ty =
  [methodDecl protectedAbstract Nothing 
   ("do"++nm++"Action") (funcparams$[(ty, "value")]) Nothing
  ,methodDecl [Public] Nothing
   "trigger" (funcparams$[(ty, "value")])
   (Just (Block [BlockStmt (ExpStmt (MethodInv (MethodCall (Name [Ident ("do"++nm++"Action")])
                                                [ExpName (Name [Ident "value"])])))]))
  ]
                                
jtype :: DType -> RefType
jtype t = case t of
     DBool    -> wrap "Boolean"
     DInt     -> wrap "Integer"
     DString  -> wrap "String"
     DPicture -> wrap "Bitmap" 
  where
    wrap :: String -> RefType
    wrap s = ClassRefType (ClassType [(Ident s,[])])

                           
}
