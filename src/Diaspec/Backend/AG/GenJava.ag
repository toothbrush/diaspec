imports
{
import Language.Java.Syntax
import Data.String.Utils (split)
import Data.Maybe (fromJust)

import Debug.Trace
}

{
type TyEnv = [(String, DType)]
}

----------------------------------
-- Java generation
----------------------------------

-- TODO split the two AGs: for pprinting and for compilation.
attr Specification
  syn genJ   :: {[CompilationUnit]}

attr Declarations
  inh pkg    :: {Maybe PackageDecl}  -- the package name, derived from specs filename
  syn genJ   :: {[CompilationUnit]}
  inh tyEnv  :: {TyEnv} -- environment to keep track of output types of components.
  syn allTypes :: {TyEnv}

attr Declaration
  inh pkg    :: {Maybe PackageDecl}  -- the package name, derived from specs filename
  syn genJ   :: {CompilationUnit}  -- pretty printing (multiline mode)
  inh tyEnv  :: {TyEnv} -- environment to keep track of output types of components.
  syn myType :: {TyEnv}

attr DType
  syn javaType :: {RefType}

attr ContextInteraction
  syn classImplements :: {[RefType]}
  inh tyEnv  :: {TyEnv} -- environment to keep track of output types of components.

sem Specification
  | S        lhs.genJ  = @ds.genJ 
             ds.tyEnv  = @ds.allTypes
             ds.pkg    = pack @name

sem Declarations
  | Cons     lhs.genJ = @hd.genJ : @tl.genJ -- TODO figure out why list is reversing
             lhs.allTypes = @hd.myType ++ @tl.allTypes
  | Nil      lhs.genJ     = []
             lhs.allTypes = []

sem DType
  | DBool    lhs.javaType = jtype @self
  | DInt     lhs.javaType = jtype @self
  | DPicture lhs.javaType = jtype @self
  | DString  lhs.javaType = jtype @self

sem Declaration
  | Source      lhs.genJ = clsSource @lhs.pkg @name @ty.javaType
                lhs.myType = [(@name, @ty.self)]
  | Action      lhs.genJ = clsAction @lhs.pkg @name @ty.javaType
                lhs.myType = []
  | Context     lhs.genJ = clsContext @lhs.pkg @name @contr.classImplements -- implements, which depend on IC.
                           @ty.self
                lhs.myType = [(@name, @ty.self)]
  | Controller  lhs.genJ = undefined
                lhs.myType = []

-- | influences name of member method, 
sem ContextInteraction
  | WhenProvided    lhs.classImplements = [ClassRefType (ClassType [(Ident "Context",[])]),
                                           ClassRefType (ClassType [(Ident "Subscriber",
                                                                     [ActualType$ jtype
                                                                      (fromJust $ lookup @name @lhs.tyEnv)])])]
  | WhenRequired    lhs.classImplements = undefined

-- 
-- | determines the return type of a context.
-- sem Publish
--   | AlwaysPublish    lhs.genJ = text $ show @self
--   | MaybePublish     lhs.genJ = text $ show @self
-- 
-- | add proxy or not
-- sem Get
--   | Nothing   lhs.genJ = empty
--   | Just      lhs.genJ = text "get" >#< text @just
-- 
-- sem ControllerInteraction
--   | WhenContext     lhs.genJ = text "when_provided" >#< text @name
--                                 >-< text "do" >#< text @act

{
clsContext :: Maybe (PackageDecl)
           -> String  -- ^ class name
           -> [RefType] -- ^ implemented interfaces. depends on interaction contract
           -> DType -- ^ output type of the context.
           -> CompilationUnit -- ^ gives back full class.
clsContext pkg clname i ty =
  clsResource pkg clname (jtype ty)
    -- extends Publisher of Ty:
    (Just (ClassRefType (ClassType [(Ident "Publisher",[ActualType$ jtype ty])])))
    -- implements:
    i -- implements Context and perhaps subscriber
    [MemberDecl $ actionMethod clname (jtype ty)] -- only one method as member

clsResource :: Maybe (PackageDecl)
            -> String  -- ^ class name
            -> RefType -- ^ type of the resource.
            -> Maybe RefType -- ^ does the class extend anything?
            -> [RefType] -- ^ what does it implement?
            -> [Decl] -- ^ body of the class
            -> CompilationUnit -- ^ give back a complete class
clsResource pkg clname ty extends implements body =
  CompilationUnit pkg [] -- no imports
  [ClassTypeDecl $ ClassDecl publicAbstract
   (Ident$ "Abstract"++clname)
   [] -- not a generic class, hence no type parameters
   extends implements
   (ClassBody body)]

clsAction :: Maybe (PackageDecl)
          -> String  -- ^ class name
          -> RefType -- ^ input type of the action.
          -> CompilationUnit -- ^ gives back full class.
clsAction pkg clname ty =
  clsResource pkg clname ty 
    Nothing -- does not extend anything
    [ClassRefType (ClassType [(Ident "Action",[])])] -- implements Action
    [MemberDecl $ actionMethod clname ty] -- only one method as member

clsSource :: Maybe (PackageDecl)  -- ^ package name
          -> String  -- ^ class name
          -> RefType -- ^ output type of the source.
          -> CompilationUnit -- ^ gives back a full class.
clsSource pkg clname ty =
  clsResource pkg clname ty 
   (Just -- all sources extend publisher, with their type as Generics param.
    (ClassRefType (ClassType [(Ident "Publisher", [ActualType ty])])))
   [ClassRefType  (ClassType [(Ident "Source",    [])])] -- implements Source interface.
   [MemberDecl $ sourceMethod clname ty] -- one method in the body

publicAbstract    = [Public,    Abstract]
protectedAbstract = [Protected, Abstract]

pack n = packagify $ concat ["fr.diaspec.", n, ".generated"]
  where packagify s = Just (PackageDecl (Name (map Ident (split "." s))))

jtype :: DType -> RefType
jtype t = case t of
     DBool    -> wrap "Boolean"
     DInt     -> wrap "Integer"
     DString  -> wrap "String"
     DPicture -> wrap "Bitmap" 
  where
    wrap :: String -> RefType
    wrap s = ClassRefType (ClassType
                             [(Ident s,[])])

methodDecl :: [Modifier] -- ^ scope modifiers, abstract, final
           -> Maybe Type -- ^ expected return type.
           -> String       -- ^ desired method name
           -> [FormalParam] -- ^ method arguments
           -> MemberDecl -- ^ a method declaration.
methodDecl scope ret nm args = MethodDecl scope [] ret (Ident nm) args
                           [] -- no exceptions
                           (MethodBody Nothing)
  
sourceMethod :: String -- ^ name of source
             -> RefType -- ^ expected return type.
             -> MemberDecl
sourceMethod nm ty = methodDecl protectedAbstract
                           (Just$ RefType ty)
                           ("get"++nm++"Value") [] -- no parameters
  
actionMethod :: String -- ^ name of source
             -> RefType -- ^ expected return type.
             -> MemberDecl
actionMethod nm ty = methodDecl protectedAbstract
                           Nothing 
                           ("do"++nm++"Action")
                           [FormalParam [] (RefType ty) False (VarId$ Ident "param")] -- formal parameters.
}
