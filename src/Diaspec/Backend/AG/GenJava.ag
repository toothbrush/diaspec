imports
{
import Language.Java.Syntax
import Data.String.Utils (split)
import Data.Maybe (fromJust)

import Debug.Trace
}

{
type TyEnv = [(String, DType)]
}

----------------------------------
-- Java generation
----------------------------------

-- TODO split the two AGs: for pprinting and for compilation.
attr Specification Declarations
  syn genJ   :: {[CompilationUnit]}

attr Declaration
  syn genJ   :: {CompilationUnit}

attr Declarations Declaration
  inh pkg      :: {Maybe PackageDecl}  -- the package name, derived from specs filename
  inh tyEnv    :: {TyEnv} -- environment to keep track of output types of components.

attr Declarations
  syn allTypes :: {TyEnv}

attr Declaration
  syn myType   :: {TyEnv}

attr DType
  syn javaType :: {RefType}

attr ContextInteraction
  syn classImplements :: {[RefType]}
  inh tyEnv    :: {TyEnv} -- environment to keep track of output types of components.
  inh ty      :: {DType}
  syn methods :: {[Decl]}

attr Publish
  inh ty      :: {DType} -- turn it into a Maybe, maybe.
  syn ret     :: {Type}
  syn notify  :: {BlockStmt}

attr Get
  syn args    :: {[Exp]}
                 
sem Specification
  | S        lhs.genJ  = @ds.genJ 
             ds.tyEnv  = @ds.allTypes
             ds.pkg    = pack @name

sem Declarations
  | Cons     lhs.genJ = @hd.genJ : @tl.genJ -- TODO figure out why list is reversing
             lhs.allTypes = @hd.myType ++ @tl.allTypes
  | Nil      lhs.genJ     = []
             lhs.allTypes = []

sem DType
  | DBool    lhs.javaType = jtype @self
  | DInt     lhs.javaType = jtype @self
  | DPicture lhs.javaType = jtype @self
  | DString  lhs.javaType = jtype @self

sem Declaration
  | Source      lhs.genJ = clsSource @lhs.pkg @name @ty.javaType
                lhs.myType = [(@name, @ty.self)]
  | Action      lhs.genJ = clsAction @lhs.pkg @name @ty.javaType
                lhs.myType = []
  | Context     lhs.genJ = clsContext @lhs.pkg @name @contr.classImplements -- implements, which depend on IC.
                           @ty.self @contr.methods
                contr.ty = @ty.self
                lhs.myType = [(@name, @ty.self)]
  | Controller  lhs.genJ = undefined
                lhs.myType = []

-- | influences name of member method, 
sem ContextInteraction
  | WhenProvided lhs.classImplements = [ClassRefType (ClassType [(Ident "Context",[])]),
                                        ClassRefType (ClassType [(Ident "Subscriber",
                                                                  [ActualType @loc.inType])])]
                 loc.inType = jtype (fromJust $ lookup @name @lhs.tyEnv) 
                 loc.methName = "on" ++ @name ++ "Provided"
                 lhs.methods= [ methodDecl protectedAbstract (Just @pub.ret) --return
                                @loc.methName
                                [FormalParam [] (RefType @loc.inType) False (VarId (Ident "newValue"))]
                                Nothing
                              , methodDecl publicFinal Nothing
                                "trigger"
                                [FormalParam [] (RefType @loc.inType) False (VarId (Ident "value"))]
                                (Just
                                 (Block
                                  [LocalVars [] @pub.ret [VarDecl (VarId (Ident "v"))
                                      (Just (InitExp (MethodInv (MethodCall
                                               (Name [Ident @loc.methName]) @get.args))))],
                                   @pub.notify]))
                              ] ++ runnerInit True
  | WhenRequired lhs.classImplements = undefined
                 lhs.methods  = []

-- | determines the return type of a context.
sem Publish
  | AlwaysPublish    lhs.ret    = RefType$ jtype @lhs.ty
                     lhs.notify = BlockStmt
                                   (ExpStmt
                                    (MethodInv (MethodCall (Name [Ident "notify"])
                                                [ExpName (Name [Ident "v"])])))
  | MaybePublish     lhs.ret    = RefType (ClassRefType (ClassType [(Ident "Maybe",[ActualType$ jtype @lhs.ty])]))
                     lhs.notify = BlockStmt
                                  (IfThen (InstanceOf (ExpName (Name [Ident "v"])) (ClassRefType (ClassType [(Ident "Just",[])])))
                                   (ExpStmt
                                    (MethodInv
                                     (MethodCall (Name [Ident "notify"])
                                      [FieldAccess
                                       (PrimaryFieldAccess
                                        (Cast
                                         (RefType
                                          (ClassRefType
                                           (ClassType
                                            [(Ident "Just",[ActualType$ jtype @lhs.ty])])))
                                         (ExpName (Name [Ident "v"]))) (Ident "just_value"))]))))

-- | add proxy or not
sem Get
  | Nothing   lhs.args = [ExpName (Name [Ident "value"])] -- no proxy needed.
  | Just      lhs.args = undefined -- TODO all the proxy stuff...

-- sem ControllerInteraction
--   | WhenContext     lhs.genJ = text "when_provided" >#< text @name
--                                 >-< text "do" >#< text @act

{
clsContext :: Maybe (PackageDecl)
           -> String  -- ^ class name
           -> [RefType] -- ^ implemented interfaces. depends on interaction contract
           -> DType -- ^ output type of the context.
           -> [Decl] -- ^ the declarations (functions, variables) to be put in the body
           -> CompilationUnit -- ^ gives back full class.
clsContext pkg clname i ty methods =
  clsResource pkg clname (jtype ty)
    -- extends Publisher of Ty:
    (Just (ClassRefType (ClassType [(Ident "Publisher",[ActualType$ jtype ty])])))
    -- implements:
    i -- implements Context and perhaps subscriber
    methods -- these depend on the interaction contract etc

clsResource :: Maybe (PackageDecl)
            -> String  -- ^ class name
            -> RefType -- ^ type of the resource.
            -> Maybe RefType -- ^ does the class extend anything?
            -> [RefType] -- ^ what does it implement?
            -> [Decl] -- ^ body of the class
            -> CompilationUnit -- ^ give back a complete class
clsResource pkg clname ty extends implements body =
  CompilationUnit pkg [] -- no imports
  [ClassTypeDecl $ ClassDecl publicAbstract
   (Ident$ "Abstract"++clname)
   [] -- not a generic class, hence no type parameters
   extends implements
   (ClassBody body)]

clsAction :: Maybe (PackageDecl)
          -> String  -- ^ class name
          -> RefType -- ^ input type of the action.
          -> CompilationUnit -- ^ gives back full class.
clsAction pkg clname ty =
  clsResource pkg clname ty 
    Nothing -- does not extend anything
    [ClassRefType (ClassType [(Ident "Action",[])])] -- implements Action
    ([actionMethod clname ty]
      ++ runnerInit False)

clsSource :: Maybe (PackageDecl)  -- ^ package name
          -> String  -- ^ class name
          -> RefType -- ^ output type of the source.
          -> CompilationUnit -- ^ gives back a full class.
clsSource pkg clname ty =
  clsResource pkg clname ty 
   (Just -- all sources extend publisher, with their type as Generics param.
    (ClassRefType (ClassType [(Ident "Publisher", [ActualType ty])])))
   [ClassRefType  (ClassType [(Ident "Source",    [])])] -- implements Source interface.
   ([sourceMethod clname ty]
     ++ runnerInit False)

publicFinal       = [Public,    Final   ]
publicAbstract    = [Public,    Abstract]
protectedAbstract = [Protected, Abstract]

pack n = packagify $ concat ["fr.diaspec.", n, ".generated"]
  where packagify s = Just (PackageDecl (Name (map Ident (split "." s))))

jtype :: DType -> RefType
jtype t = case t of
     DBool    -> wrap "Boolean"
     DInt     -> wrap "Integer"
     DString  -> wrap "String"
     DPicture -> wrap "Bitmap" 
  where
    wrap :: String -> RefType
    wrap s = ClassRefType (ClassType
                             [(Ident s,[])])

methodDecl :: [Modifier] -- ^ scope modifiers, abstract, final
           -> Maybe Type -- ^ expected return type.
           -> String       -- ^ desired method name
           -> [FormalParam] -- ^ method arguments
           -> Maybe Block
           -> Decl -- ^ a method declaration.
methodDecl scope ret nm args bod = MemberDecl$ MethodDecl scope [] ret (Ident nm) args
                           [] -- no exceptions
                           (MethodBody bod)
  
sourceMethod :: String -- ^ name of source
             -> RefType -- ^ expected return type.
             -> Decl
sourceMethod nm ty = methodDecl protectedAbstract
                           (Just$ RefType ty)
                           ("get"++nm++"Value") [] -- no parameters
                           Nothing
  
actionMethod :: String -- ^ name of source
             -> RefType -- ^ expected return type.
             -> Decl
actionMethod nm ty = methodDecl protectedAbstract
                           Nothing 
                           ("do"++nm++"Action")
                           [FormalParam [] (RefType ty) False (VarId$ Ident "param")] -- formal parameters.
                           Nothing

runnerInit :: Bool -- ^ should it be Final?
           -> [Decl]
runnerInit b    = [ MemberDecl (FieldDecl [] (RefType (ClassRefType (ClassType [(Ident "AbstractRunner",[])])))
                                [VarDecl (VarId (Ident "runner")) Nothing])
                  , MemberDecl (MethodDecl (modifiers b) [] Nothing
                                (Ident "init")
                                [FormalParam [] (RefType (ClassRefType (ClassType [(Ident "AbstractRunner",[])]))) False (VarId (Ident "runner"))] []
                                (MethodBody (Just (Block [BlockStmt (ExpStmt (Assign (FieldLhs (PrimaryFieldAccess This (Ident "runner"))) EqualA (ExpName (Name [Ident "runner"]))))]))))
                  ]
  where modifiers True = [Final, Protected]
        modifiers False = [Protected]



                           
}
