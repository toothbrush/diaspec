{
import qualified Language.Java.Syntax as J
import Data.String.Utils (split)
}

----------------------------------
-- Java generation
----------------------------------
-- attr Specification
  -- inh projName :: {String}

attr Declaration
  inh projName :: {String}  -- the package name, derived from specs filename
  syn genJ     :: {J.CompilationUnit}  -- pretty printing (multiline mode)

attr Type
  syn genJ :: {J.RefType}

sem Type
  | Bool    lhs.genJ = jtype @self
  | Int     lhs.genJ = jtype @self
  | Picture lhs.genJ = jtype @self
  | String  lhs.genJ = jtype @self


sem Declaration
  | Source      lhs.genJ = clsSource @loc.pkg @name @ty.genJ
                loc.pkg  = pack @lhs.projName 
  | Action      lhs.genJ = clsAction @loc.pkg @name @ty.genJ
                loc.pkg  = pack @lhs.projName 
  | Context     lhs.genJ = undefined -- clsContext @name @ty.genJ 
                loc.pkg  = pack @lhs.projName 
  | Controller  lhs.genJ = undefined
                loc.pkg  = pack @lhs.projName 

-- | determines the return type of a context.
-- sem Publish
--   | AlwaysPublish    lhs.genJ = text $ show @self
--   | MaybePublish     lhs.genJ = text $ show @self
-- 
-- sem ControllerInteraction
--   | WhenContext     lhs.genJ = text "when_provided" >#< text @name
--                                 >-< text "do" >#< text @act
-- | influences name, 
-- sem ContextInteraction
--   | WhenRequired    lhs.genJ = text "when_required" >-< @get.genJ
--   | WhenProvided    lhs.genJ = text "when_provided" >#< text @name
--                                 >-< @get.genJ >-< @pub.genJ
-- 
-- | add proxy or not
-- sem Get
--   | Nothing   lhs.genJ = empty
--   | Just      lhs.genJ = text "get" >#< text @just

{

clsResource :: Maybe (J.PackageDecl)
            -> String  -- ^ class name
            -> J.RefType -- ^ type of the resource.
            -> Maybe J.RefType -- ^ does the class extend anything?
            -> [J.RefType] -- ^ what does it implement?
            -> [J.Decl] -- ^ body of the class
            -> J.CompilationUnit -- ^ give back a complete class
clsResource pkg clname ty extends implements body =
  J.CompilationUnit pkg [] -- no imports
  [J.ClassTypeDecl $ J.ClassDecl publicAbstract
   (J.Ident$ "Abstract"++clname)
   [] -- not a generic class, hence no type parameters
   extends implements
   (J.ClassBody body)]

clsAction :: Maybe (J.PackageDecl)
          -> String  -- ^ class name
          -> J.RefType -- ^ input type of the action.
          -> J.CompilationUnit -- ^ gives back full class.
clsAction pkg clname ty =
  clsResource pkg clname ty 
    Nothing -- does not extend anything
    [J.ClassRefType (J.ClassType [(J.Ident "Action",[])])] -- implements Action
    [J.MemberDecl $ actionMethod clname ty] -- only one method as member

clsSource :: Maybe (J.PackageDecl)  -- ^ package name
          -> String  -- ^ class name
          -> J.RefType -- ^ output type of the source.
          -> J.CompilationUnit -- ^ gives back a full class.
clsSource pkg clname ty =
  clsResource pkg clname ty 
   (Just -- all sources extend publisher, with their type as Generics param.
    (J.ClassRefType (J.ClassType [(J.Ident "Publisher", [J.ActualType ty])])))
   [J.ClassRefType  (J.ClassType [(J.Ident "Source",    [])])] -- implements Source interface.
   [J.MemberDecl $ sourceMethod clname ty] -- one method in the body

publicAbstract    = [J.Public,    J.Abstract]
protectedAbstract = [J.Protected, J.Abstract]

pack n = packagify $ concat ["fr.diaspec.", n, ".generated"]
  where packagify s = Just (J.PackageDecl (J.Name (map J.Ident (split "." s))))

jtype :: Type -> J.RefType
jtype t = case t of
     Bool    -> wrap "Boolean"
     Int     -> wrap "Integer"
     String  -> wrap "String"
     Picture -> wrap "Bitmap" 
  where
    wrap :: String -> J.RefType
    wrap s = J.ClassRefType (J.ClassType
                             [(J.Ident s,[])])

methodDecl :: [J.Modifier] -- ^ scope modifiers, abstract, final
           -> Maybe J.Type -- ^ expected return type.
           -> String       -- ^ desired method name
           -> [J.FormalParam] -- ^ method arguments
           -> J.MemberDecl -- ^ a method declaration.
methodDecl scope ret nm args = J.MethodDecl scope [] ret (J.Ident nm) args
                           [] -- no exceptions
                           (J.MethodBody Nothing)
  
sourceMethod :: String -- ^ name of source
             -> J.RefType -- ^ expected return type.
             -> J.MemberDecl
sourceMethod nm ty = methodDecl protectedAbstract
                           (Just$ J.RefType ty)
                           ("get"++nm++"Value") [] -- no parameters
  
actionMethod :: String -- ^ name of source
             -> J.RefType -- ^ expected return type.
             -> J.MemberDecl
actionMethod nm ty = methodDecl protectedAbstract
                           Nothing 
                           ("do"++nm++"Action")
                           [J.FormalParam [] (J.RefType ty) False (J.VarId$ J.Ident "param")] -- formal parameters.
}
