imports
{
import Language.Java.Syntax
import Data.String.Utils (split)
}

----------------------------------
-- Java generation
----------------------------------
-- attr Specification
  -- inh projName :: {String}

attr Declaration
  inh projName :: {String}  -- the package name, derived from specs filename
  syn genJ     :: {CompilationUnit}  -- pretty printing (multiline mode)

attr DType
  syn genJ :: {RefType}

sem DType
  | DBool    lhs.genJ = jtype @self
  | DInt     lhs.genJ = jtype @self
  | DPicture lhs.genJ = jtype @self
  | DString  lhs.genJ = jtype @self


sem Declaration
  | Source      lhs.genJ = clsSource @loc.pkg @name @ty.genJ
                loc.pkg  = pack @lhs.projName 
  | Action      lhs.genJ = clsAction @loc.pkg @name @ty.genJ
                loc.pkg  = pack @lhs.projName 
  | Context     lhs.genJ = clsContext @loc.pkg @name Nothing -- input, which depends on interaction contract.
                           @ty.genJ -- must add intrcontr
                loc.pkg  = pack @lhs.projName 
  | Controller  lhs.genJ = undefined
                loc.pkg  = pack @lhs.projName 

-- | influences name of member method, 
-- sem ContextInteraction
--   | WhenRequired    lhs.genJ = text "when_required" >-< @get.genJ
--   | WhenProvided    lhs.genJ = text "when_provided" >#< text @name
--                                 >-< @get.genJ >-< @pub.genJ
-- 
-- | determines the return type of a context.
-- sem Publish
--   | AlwaysPublish    lhs.genJ = text $ show @self
--   | MaybePublish     lhs.genJ = text $ show @self
-- 
-- | add proxy or not
-- sem Get
--   | Nothing   lhs.genJ = empty
--   | Just      lhs.genJ = text "get" >#< text @just
-- 
-- sem ControllerInteraction
--   | WhenContext     lhs.genJ = text "when_provided" >#< text @name
--                                 >-< text "do" >#< text @act

{
clsContext :: Maybe (PackageDecl)
           -> String  -- ^ class name
           -> Maybe RefType -- ^ input type of the context, if a subscriber.
           -> RefType -- ^ output type of the context.
           -> CompilationUnit -- ^ gives back full class.
clsContext pkg clname i ty =
  clsResource pkg clname ty 
    Nothing -- does not extend anything
    [ClassRefType (ClassType [(Ident "Action",[])])] -- implements Action
    [MemberDecl $ actionMethod clname ty] -- only one method as member

clsResource :: Maybe (PackageDecl)
            -> String  -- ^ class name
            -> RefType -- ^ type of the resource.
            -> Maybe RefType -- ^ does the class extend anything?
            -> [RefType] -- ^ what does it implement?
            -> [Decl] -- ^ body of the class
            -> CompilationUnit -- ^ give back a complete class
clsResource pkg clname ty extends implements body =
  CompilationUnit pkg [] -- no imports
  [ClassTypeDecl $ ClassDecl publicAbstract
   (Ident$ "Abstract"++clname)
   [] -- not a generic class, hence no type parameters
   extends implements
   (ClassBody body)]

clsAction :: Maybe (PackageDecl)
          -> String  -- ^ class name
          -> RefType -- ^ input type of the action.
          -> CompilationUnit -- ^ gives back full class.
clsAction pkg clname ty =
  clsResource pkg clname ty 
    Nothing -- does not extend anything
    [ClassRefType (ClassType [(Ident "Action",[])])] -- implements Action
    [MemberDecl $ actionMethod clname ty] -- only one method as member

clsSource :: Maybe (PackageDecl)  -- ^ package name
          -> String  -- ^ class name
          -> RefType -- ^ output type of the source.
          -> CompilationUnit -- ^ gives back a full class.
clsSource pkg clname ty =
  clsResource pkg clname ty 
   (Just -- all sources extend publisher, with their type as Generics param.
    (ClassRefType (ClassType [(Ident "Publisher", [ActualType ty])])))
   [ClassRefType  (ClassType [(Ident "Source",    [])])] -- implements Source interface.
   [MemberDecl $ sourceMethod clname ty] -- one method in the body

publicAbstract    = [Public,    Abstract]
protectedAbstract = [Protected, Abstract]

pack n = packagify $ concat ["fr.diaspec.", n, ".generated"]
  where packagify s = Just (PackageDecl (Name (map Ident (split "." s))))

jtype :: DType -> RefType
jtype t = case t of
     DBool    -> wrap "Boolean"
     DInt     -> wrap "Integer"
     DString  -> wrap "String"
     DPicture -> wrap "Bitmap" 
  where
    wrap :: String -> RefType
    wrap s = ClassRefType (ClassType
                             [(Ident s,[])])

methodDecl :: [Modifier] -- ^ scope modifiers, abstract, final
           -> Maybe Type -- ^ expected return type.
           -> String       -- ^ desired method name
           -> [FormalParam] -- ^ method arguments
           -> MemberDecl -- ^ a method declaration.
methodDecl scope ret nm args = MethodDecl scope [] ret (Ident nm) args
                           [] -- no exceptions
                           (MethodBody Nothing)
  
sourceMethod :: String -- ^ name of source
             -> RefType -- ^ expected return type.
             -> MemberDecl
sourceMethod nm ty = methodDecl protectedAbstract
                           (Just$ RefType ty)
                           ("get"++nm++"Value") [] -- no parameters
  
actionMethod :: String -- ^ name of source
             -> RefType -- ^ expected return type.
             -> MemberDecl
actionMethod nm ty = methodDecl protectedAbstract
                           Nothing 
                           ("do"++nm++"Action")
                           [FormalParam [] (RefType ty) False (VarId$ Ident "param")] -- formal parameters.
}
